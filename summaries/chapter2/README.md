# Chapter 2

`strace` is a utility for Linux which provides the function monitoring interactions between processes and Linux Kernel.  
The number of lines in the file generated by `strace` means total invoking times of system call.
```bash
root@84ecd6f3285c:/home/scripts/chapter2% cc -o hello hello.c
root@84ecd6f3285c:/home/scripts/chapter2% strace -o hello.log ./hello
hello world
root@84ecd6f3285c:/home/scripts/chapter2% cat -n hello.log
     1	execve("./hello", ["./hello"], 0x7ffce31a4f20 /* 9 vars */) = 0
     2	brk(NULL)                               = 0x557d8b462000
     3	access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
     4	access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
     5	openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
     6	fstat(3, {st_mode=S_IFREG|0644, st_size=13626, ...}) = 0
     7	mmap(NULL, 13626, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f75f9a7b000
     8	close(3)                                = 0
     9	access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    10	openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
    11	read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
    12	fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
    13	mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f75f9a79000
    14	mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f75f9467000
    15	mprotect(0x7f75f964e000, 2097152, PROT_NONE) = 0
    16	mmap(0x7f75f984e000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f75f984e000
    17	mmap(0x7f75f9854000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f75f9854000
    18	close(3)                                = 0
    19	arch_prctl(ARCH_SET_FS, 0x7f75f9a7a4c0) = 0
    20	mprotect(0x7f75f984e000, 16384, PROT_READ) = 0
    21	mprotect(0x557d8ac3b000, 4096, PROT_READ) = 0
    22	mprotect(0x7f75f9a7f000, 4096, PROT_READ) = 0
    23	munmap(0x7f75f9a7b000, 13626)           = 0
    24	fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
    25	brk(NULL)                               = 0x557d8b462000
    26	brk(0x557d8b483000)                     = 0x557d8b483000
    27	write(1, "hello world\n", 12)           = 12
    28	exit_group(0)                           = ?
    29	+++ exited with 0 +++
```
By the above log I found `hello.c` invoked system calls total of 29 times and `write()` system call.

By comparing `hello.py`'s strace log with the `hello.c`'s log, you will find the number of lines by python is more than that by `hello.c` because the implementation of Python is more complex than that of C.  
```bash
root@84ecd6f3285c:/home/scripts/chapter2% strace -o hello.py.log python3 ./hello.py
Hello world
root@84ecd6f3285c:/home/scripts/chapter2% cat hello.py.log | wc -l
522
```
This log also shows `hello.py` invoked the `write()` system call.
```bash
root@84ecd6f3285c:/home/scripts/chapter2% cat hello.py.log | grep -n write
517:write(1, "Hello world\n", 12)           = 12
```

Next, invoking `loop.c` and monitoring a process by `sar -P`.  
The `%user` column means the rate of user mode process in CPU.  
Other columns are in the same.
```bash
root@84ecd6f3285c:/home/scripts/chapter2% cc -o loop loop.c
root@84ecd6f3285c:/home/scripts/chapter2% ./loop &
[1] 169
root@84ecd6f3285c:/home/scripts/chapter2% sar -P ALL 1 1
Linux 4.9.125-linuxkit (84ecd6f3285c) 	02/24/19 	_x86_64_	(4 CPU)

09:13:06        CPU     %user     %nice   %system   %iowait    %steal     %idle
09:13:07        all     25.06      0.00      0.00      0.00      0.00     74.94
09:13:07          0    100.00      0.00      0.00      0.00      0.00      0.00
09:13:07          1      0.00      0.00      0.00      0.00      0.00    100.00
09:13:07          2      0.00      0.00      0.00      0.00      0.00    100.00
09:13:07          3      0.00      0.00      0.00      0.00      0.00    100.00

Average:        CPU     %user     %nice   %system   %iowait    %steal     %idle
Average:        all     25.06      0.00      0.00      0.00      0.00     74.94
Average:          0    100.00      0.00      0.00      0.00      0.00      0.00
Average:          1      0.00      0.00      0.00      0.00      0.00    100.00
Average:          2      0.00      0.00      0.00      0.00      0.00    100.00
Average:          3      0.00      0.00      0.00      0.00      0.00    100.00
```
The report shows `hello.c` always runs on the user mode.  
Next I try to use the system mode.
```bash
root@84ecd6f3285c:/home/scripts/chapter2% cc -o ppidloop ppidloop.c
root@84ecd6f3285c:/home/scripts/chapter2% ./ppidloop &
[1] 178
root@84ecd6f3285c:/home/scripts/chapter2% sar -P ALL 1 1
Linux 4.9.125-linuxkit (84ecd6f3285c) 	02/24/19 	_x86_64_	(4 CPU)

09:53:10        CPU     %user     %nice   %system   %iowait    %steal     %idle
09:53:11        all      9.05      0.00     16.08      0.00      0.00     74.87
09:53:11          0     36.00      0.00     64.00      0.00      0.00      0.00
09:53:11          1      0.00      0.00      0.00      0.00      0.00    100.00
09:53:11          2      0.00      0.00      0.00      0.00      0.00    100.00
09:53:11          3      0.00      0.00      0.00      0.00      0.00    100.00

Average:        CPU     %user     %nice   %system   %iowait    %steal     %idle
Average:        all      9.05      0.00     16.08      0.00      0.00     74.87
Average:          0     36.00      0.00     64.00      0.00      0.00      0.00
Average:          1      0.00      0.00      0.00      0.00      0.00    100.00
Average:          2      0.00      0.00      0.00      0.00      0.00    100.00
Average:          3      0.00      0.00      0.00      0.00      0.00    100.00
```
This report shows `CPU 0` processes the task at a rate of 36% on the user mode and at a rate of 64% on the kernel mode.

`glibc` is a standard C library and a wrapper function of system calls.  
We find what libaries a program uses by `ldd`.
```bash
root@84ecd6f3285c:/home/scripts/chapter2% ldd /bin/echo
	linux-vdso.so.1 (0x00007fff23d08000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd94781b000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fd947e15000)
root@84ecd6f3285c:/home/scripts/chapter2% ldd ppidloop
	linux-vdso.so.1 (0x00007ffc911b6000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa19f837000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fa19fe2a000)
root@84ecd6f3285c:/home/scripts/chapter2% ldd /usr/bin/python3
	linux-vdso.so.1 (0x00007fff5dd24000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f87cfe0d000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f87cfbee000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f87cf9ea000)
	libutil.so.1 => /lib/x86_64-linux-gnu/libutil.so.1 (0x00007f87cf7e7000)
	libexpat.so.1 => /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f87cf5b5000)
	libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f87cf398000)
	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f87ceffa000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f87d01fe000)
```
`libc` is a standard C library, hence `echo` and `python3` use internally the standard C library.

## References
- [［試して理解］Linuxのしくみ～実験と図解で学ぶOSとハードウェアの基礎知識](https://gihyo.jp/book/2018/978-4-7741-9607-7)